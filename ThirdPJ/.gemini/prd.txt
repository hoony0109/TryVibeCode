게임 운영툴 개발 로드맵
1단계: 환경 설정 및 기술 스택 구성 (Setup)
아키텍처 구성 개요: MySQL(게임/운영 데이터 저장), Redis(캐시 및 세션 관리), MongoDB(로그/통계 데이터 저장), TCP 소켓(게임 서버 실시간 통신) 등의 기술 스택 결정 및 설정
프론트엔드 React 프로젝트 초기화 (CRA 혹은 Vite 이용, 폴더 구조 설계, 라우터 설정 등)
백엔드 Node.js(Express 등) 프로젝트 생성 및 기본 구조 구축 (ESLint/Prettier 설정, 프로젝트 디렉토리 구조 정의)
MySQL 데이터베이스 연결 설정 및 스키마 준비: 운영툴 전용 DB 및 테이블 생성 (예: 운영자 계정, 쿠폰 등), 게임 서버 DB와의 연결 설정 (읽기 전용 계정 등)
Redis 서버 연결 설정 (세션 저장소 또는 캐시 용도, redis 클라이언트 설정 및 연결 테스트)
MongoDB 연결 설정 (향후 로그 및 비정형 데이터 저장 용도, Mongoose 등 ODM 설정)
환경 변수 설정 (.env 작성하여 DB 접속정보, 게임 서버 IP/포트, 비밀키 등 관리) 및 초기 관리자 계정 생성 (DB에 해시 비밀번호로 등록)
2단계: 인증 및 권한 관리 구축 (Core Infrastructure)
운영자 로그인 인증 기능 구현: 백엔드 로그인 API 개발 (bcrypt로 비밀번호 해시 검증, JWT 발급 또는 세션 생성) 및 로그인 UI 구현
운영자 계정 관리 및 권한 시스템 설계: MySQL에 운영자 계정 테이블 생성 (필드: ID, 이름, 역할, 비밀번호 해시 등) 및 기본 admin 계정 등록
권한(Role) 기반 접근 제어 미들웨어 개발: 메뉴별 권한 매핑 정의, JWT 클레임 또는 세션정보로 권한 체크하여 메뉴별 접근 제한 적용. 민감 메뉴의 경우 2단계 인증(OTP) 옵션 고려
Redis 세션 관리 도입 (JWT를 사용하지 않는다면): 로그인 세션을 Redis에 저장하여 다중 서버 환경 대비, 세션 만료 및 로그아웃 처리 구현
운영자 활동 로그 기반구조 준비: 운영자가 수행하는 주요 액션에 대해 로그 남기는 로직 구현 (예: 아이템 지급, 계정 차단 시 DB 또는 MongoDB에 기록) – 실제 조회 UI는 추후 구현
게임 서버 TCP 소켓 클라이언트 모듈 개발: Node.js 백엔드에서 게임 서버와의 통신을 위한 소켓 연결 설정 (예: net.Socket 사용). 기본 핑/퐁 또는 상태조회 명령으로 연결 테스트
3단계: 공통 UI 레이아웃 및 대시보드 구현 (Dashboard)
운영툴 전반의 메인 레이아웃 구축: React로 사이드 메뉴 및 헤더 컴포넌트 구현, 1단계에서 정의한 메뉴 구조에 따라 라우트 구성 (대시보드, 플레이어 관리 등 빈 페이지 연결)
대시보드 화면 개발: 운영자가 로그인 시 처음 보게 되는 핵심 지표 화면 구성. 차트 위젯과 통계 카드 컴포넌트를 사용하여 실시간 지표 표시
실시간 운영 지표 섹션: CCU(동접), DAU, 신규 유저 수, 매출 등의 KPI를 시각화 (예: 전일 대비 증감 표시). 초기에는 테스트 데이터 또는 간단한 쿼리 결과로 표시하고, 추후 실제 통계 연동
서버 상태 모니터링 패널: 각 게임 서버의 접속자 수와 상태(정상/점검/장애)를 실시간 표시. 백엔드에서 일정 주기로 게임 서버에 TCP로 상태 요청하거나, 게임 서버가 주기적으로 Redis에 업데이트한 CCU 값을 조회하여 표시
최근 승인 내역 및 보안 알림 위젯: 현재는 승인 Workflow 미구현이므로 UI만 틀 구축 (최근 운영 작업 로그를 보여줄 영역). 보안 알림도 추후 비정상 활동 탐지 연동 예정이므로 placeholder 형태로 배치
대시보드 차트 컴포넌트 개발: 예를 들어 접속자 추이, 매출 추이 등에 대한 라인차트/막대차트 표시를 위해 Chart.js 또는 Recharts 도입. 차트와 표 동시 제공하여 핵심 데이터 한눈에 파악
4단계: 플레이어 관리 기능 구현 (Player Management)
계정 관리: 플레이어 계정 검색 및 상세조회 API 구현 (MySQL 게임 계정 테이블에서 계정 ID, 닉네임, 상태, 최근 접속 IP, 밴(잠금) 여부 등을 조회). React UI에서 계정 ID/닉네임으로 검색 폼 제공, 결과를 표 형태로 표시 (정렬/필터/페이지네이션 지원)
캐릭터 조회 및 상세 정보: 선택된 계정의 캐릭터 리스트를 불러오는 API 구현 (캐릭터명, 레벨, 직업, 잠금 여부 등). 특정 캐릭터 선택 시 상세 정보 조회(인벤토리 아이템, 장착 장비, 진행 중인 퀘스트 등)를 위한 API 개발. 활동 로그 요약(최근 접속 시간, 최근 획득 아이템 등)을 함께 표시
콘텐츠 진행 현황: 해당 플레이어의 게임 진행 데이터를 조회 (예: 던전 클리어 단계, 주요 퀘스트 진행도 등). 관련 게임 DB 테이블이나 로그에서 정보를 가져와 UI에 표시하여, 유저의 콘텐츠 소화 정도를 파악
플레이어 관계 정보: 친구 목록, 차단 목록 조회 기능 구현. 친구/차단 정보 테이블 조회 API 및 UI 탭으로 표시
플레이어 정보 관리 및 제재 기능: 운영자가 계정을 직접 제어할 수 있는 기능 구현
계정 잠금/해제: 운영툴에서 계정을 밴하거나 해제할 수 있도록 API 제공 (MySQL 계정 상태 필드 업데이트; 잠금 시 게임 서버에 통보하여 즉시 접속 종료 유도 가능)
캐릭터 강제 접속 종료 또는 활동 제한: 필요 시 특정 캐릭터를 강제로 로그아웃시키는 명령(TCP)을 게임 서버에 전송하는 기능 (선택 사항)
인증 정보 변경: 유저 비밀번호 초기화나 이메일 등 인증 정보 수정 기능 노출 여부 결정 및 구현 (요청이 있을 경우에만 사용하도록 UI 제공)
아이템 지급/회수: 선택된 플레이어에게 아이템이나 재화를 지급하는 기능 구현 (관리자 권한으로 보상 지급). 주의: 해당 기능은 오남용 위험이 있으므로 2인 승인 프로세스 연계 고려 (승인 요청 생성 후 승인 시 적용되도록, 추후 10단계에서 워크플로우 연동)
프론트엔드 UI: 플레이어 관리 화면에 검색 및 필터 UI, 결과 테이블 컴포넌트 구현. 모든 조회 결과는 CSV/Excel로 내보내기 가능하도록 옵션 제공. 데이터가 많을 경우 무한스크롤 또는 페이지네이션 적용
성능 및 저장소 고려: 플레이어 정보 조회 시 요청 빈도가 높을 수 있으므로 Redis 캐싱 검토 (예: 동일 계정에 대한 반복 조회 시 일정 시간 캐시). 다만 데이터 일관성이 중요하므로 캐시는 짧은 TTL로 활용하거나 주요 데이터만 캐시
5단계: 게임 서비스 운영 기능 I – 공지, 콘텐츠 제어, 서버 설정
공지사항 관리 기능 구현: 메인 공지 및 실시간 공지를 작성/게시/수정/삭제할 수 있는 UI 제공
공지 작성 폼 (제목, 내용, 노출 서버 또는 대상, 기간 등) 구현 및 미리보기 기능
공지 데이터 저장: MySQL에 공지사항 테이블 설계 (공지 타입, 내용, 시작/종료 시간, 작성자 등) 후 공지 등록 시 해당 테이블에 저장
공지 배포: 새 공지 등록 또는 수정 시 게임 서버에 즉시 반영되도록 백엔드에서 처리. 예: 게임 서버가 주기적으로 DB의 공지 테이블을 확인하거나, 운영툴 백엔드에서 게임 서버로 TCP 메시지(공지 내용 전달) 전송하여 실시간 공지 뿌리기
공지 목록 및 상태 표시 UI (게시중/비게시 구분, 일정이 지난 공지 자동 만료 등) 구현
콘텐츠 접근 제어 기능 구현: 게임 내 특정 콘텐츠를 ON/OFF 전환하는 관리자 기능
운영툴 UI에서 콘텐츠 리스트와 현재 활성 상태를 표시하고 토글 스위치로 제어할 수 있게 구성 (예: 던전, 이벤트 퀘스트 등의 항목별 ON/OFF)
콘텐츠 활성화 상태를 저장하는 설정 테이블(MySQL) 구축 (콘텐츠 ID, 상태, 변경 일시, 변경자, 비활성화 사유 등 기록)
상태 변경 시 백엔드에서 즉시 게임 서버에 통보: TCP 소켓을 통해 해당 콘텐츠 ID를 비활성화하도록 명령 전송. 게임 서버에서는 해당 콘텐츠 접근을 제한하고 모든 관련 사용자에게 변경 사항 전파
변경 이력 관리: 누가 언제 어떤 콘텐츠를 끄거나 켰는지 MySQL에 로그 남기기 (사유 포함)
서버 설정 관리 기능 구현: 게임 서비스 접속 관련 설정을 실시간 관리
서버 노출 제어: 서버별로 접속 노출 여부 On/Off 전환 (예: 신규 서버를 열거나 점검 시 서버 리스트에서 숨김). UI에서 서버 목록과 노출 상태 토글 제공, 변경 시 해당 상태를 MySQL의 서버정보 테이블에 업데이트하고 게임 로비 서버에 TCP로 알려 로그인 허용/차단 처리
추천 서버 지정: 특정 서버를 추천 서버로 표시하도록 플래그 설정 (UI에서 서버 선택 후 "추천" 마크 토글, DB에 추천 서버 필드 업데이트)
IP 접근 제한 관리: IP 차단/허용 리스트 관리 UI. 특정 IP 또는 대역을 입력하여 차단 추가 가능. MySQL에 IP 제한 테이블 저장 및 변경 시 게임 서버 방화벽 설정이나 내부 IP 체크 리스트에 반영 (TCP로 변경 내용 전달하거나 Redis pub/sub로 실시간 동기화)
UI에서 현재 설정된 IP 제한 목록과 서버 노출 현황을 한눈에 확인하도록 대시보드화
백엔드 API 연동: 공지/콘텐츠/서버 설정 변경에 대한 Node.js API 개발. DB 업데이트 성공 시 필요한 경우 게임 서버 소켓 통신 또는 Redis publish 등을 통해 즉각 반영. 예외 상황에 대비한 오류 처리 (예: 서버 미응답 시 재시도 로직)
6단계: 게임 서비스 운영 기능 II – 푸시, 메일, 쿠폰
푸시 발송 관리 구현: 모바일 게임일 경우 중요 기능으로, FCM/APNS 등을 통해 유저들에게 푸시 알림을 보낼 수 있음
푸시 메시지 작성 UI: 제목, 내용, 대상(전체/특정 조건), 플랫폼(Android/iOS) 선택, 예약 발송 시간 옵션
백엔드 푸시 스케줄러: 예약 시간이 설정된 경우를 대비하여 Node.js에서 스케줄 작업 구현 (예: node-cron 사용 또는 Redis 기반 delayed queue 구축). 예약 시 해당 요청을 DB에 저장(MySQL 푸시 예약 테이블: 메시지, 시간, 대상 등)하고 스케줄러가 시간 도래 시 발송 처리
푸시 발송 처리: FCM/APNS 연동 모듈 설정하여 해당 서비스로 메시지 전송. 만약 게임 서버가 자체 푸시 기능을 제공한다면, 게임 서버로 TCP 메시지를 보내 모든 접속자 또는 대상에게 in-app notification 구현
발송 결과 저장: 성공/실패 여부 및 시간 등을 MySQL 로그 테이블 기록, 운영툴 UI에서 발송 이력 확인 가능하도록 목록/필터 제공
메일 발송 관리 구현: 게임 내 우편함을 통한 공지/보상 지급 시스템
메일 작성 UI: 수신 대상 (전체 유저, 개별 유저ID 등), 제목, 본문 내용, 첨부 아이템/재화 선택, 즉시 발송 or 예약 시간
백엔드 메일 발송 API: MySQL에 메일 테이블에 기록 (예: 대상, 내용, 첨부, 발송 여부 등). 전체 유저 대상일 경우 대상 필드에 “ALL” 등을 사용하거나, 발송 시 게임 서버에서 모든 현재 접속자/또는 다음 접속 시 우편 지급 처리
게임 서버 연계: 메일 등록 후 즉시 발송인 경우 게임 서버에 Socket으로 새 우편 정보 전달. 예약의 경우 푸시와 유사하게 스케줄러가 시간 도래 시 게임 서버에 발송 지시
발송 상태 갱신: 메일이 게임 서버에 의해 실제 발송되면 상태를 업데이트 (예: 발송 완료, 실패 시 재시도 여부). 운영툴에서 해당 상태를 조회 가능
쿠폰 관리 구현: 프로모션 쿠폰 코드 생성 및 사용 내역 관리
쿠폰 생성 UI: 쿠폰 이벤트명, 지급 아이템/재화 구성, 유효 기간, 생성할 쿠폰 개수 등을 입력할 폼 제공
쿠폰 코드 대량 생성: 백엔드에서 입력된 수량만큼 고유 쿠폰 코드를 생성하는 로직 구현 (영문+숫자 랜덤 생성 혹은 특정 패턴). 코드의 중복을 방지하고 지정한 수량만큼 빠르게 생성하기 위해 알고리즘 최적화, 대량 생성 시 비동기로 처리
MySQL에 쿠폰 테이블/코드 테이블 설계: 쿠폰 마스터 테이블(이벤트명, 보상내용, 유효기간 등) 및 개별 코드 테이블(코드값, 남은 사용량 또는 1회용 플래그, 생성된 이벤트 ID 참조, 사용 여부 등) 저장
운영툴 UI에서 생성된 쿠폰 코드 리스트를 조회 및 Excel로 내보내기 기능 제공 (마케팅팀 등이 코드 목록을 다운로드 가능)
쿠폰 사용 내역 조회: 플레이어가 쿠폰을 사용했을 때의 로그 조회 기능. MySQL 쿠폰 사용 로그 테이블 또는 게임 서버 로그를 조회하여, 어떤 계정이 언제 어떤 쿠폰을 사용했는지 UI에 표시
쿠폰 사용 검증(게임 연동): 게임 서버에서 쿠폰 코드를 입력 받으면 운영툴의 DB를 조회하거나 내부 API를 호출해 코드 유효성 확인 및 보상 지급. 이때 이미 사용된 코드이거나 만료된 경우 처리 로직 마련
추가기능 및 고려사항:
대량 발송/생성 작업의 경우 백그라운드 작업으로 처리하고 진행 상황을 UI에 피드백 (예: 진행률 표시). Node.js에서 Queue(큐) 시스템 도입 검토 (BeeQueue, Bull 등 + Redis 활용)
중요한 발송 작업(전체 푸시, 전체 메일, 쿠폰 대량 생성 등)에 대해서는 이중 승인 옵션 적용 고려 (실수로 잘못 보내는 것을 방지하기 위해 10단계 승인 Workflow와 연계)
푸시의 경우 플랫폼별 제한이나 쿼터 고려 (FCM은 1분에 X건 제한 등 정책 확인)
7단계: 상점 및 매출 관리 기능 (Shop Management & Revenue)
결제 내역 조회 모듈 구현: 유저들의 인앱 결제 기록을 확인하는 메뉴
결제 내역 리스트 UI: 기간별, 사용자별, 상품별 필터를 제공하여 특정 범위의 결제 기록을 조회. 표 형태로 주문 ID, 유저ID, 상품명, 결제 금액, 결제 플랫폼(Google/Apple 등), 결제 시간 등의 정보를 표시
백엔드 API: MySQL에 저장된 결제 거래 테이블에서 필터 조건에 따른 레코드 조회. 필요한 경우 외부 스토어 영수증 검증 API와 연동하여 결제 내역의 정확성 확보 (운영툴에서는 조회만 수행하고 검증은 게임 서버에서 이뤄졌다고 가정)
환불/취소 여부 표시: 결제 내역에 취소 또는 환불된 건이 있다면 상태를 구분 표시 (게임 DB에 해당 플래그 존재 시 반영)
시간대별 매출 통계 기능 구현: 일정 주기(시간/일/월)별 매출 합계를 시각화하여 매출 추이를 모니터링
프론트엔드: 차트 컴포넌트로 시간대별 매출 그래프 제공 (예: 지난 24시간 시간별 매출, 또는 선택 기간 일별 매출). 누적 매출과 평균 매출 등도 표시
백엔드: 통계 데이터 산출 로직 – MySQL 결제 내역으로부터 그룹별 합계 쿼리. 대량 데이터일 경우 성능을 위해 미리 집계된 테이블 사용 고려 (예: 하루/시간별 매출 집계 테이블을 배치 작업으로 업데이트)
Redis 캐싱: 동일한 통계 조회 요청이 빈번할 경우를 대비해 최근 계산 결과를 Redis에 캐시하여 응답 속도 향상. 새 결제가 발생하면 캐시 무효화 또는 적절히 갱신
비결제 재화 거래 내역 확인 기능: 현금으로 구매도 가능한 유료 재화(예: 다이아몬드 등)이 게임 내에서 어떻게 거래되었는지 모니터링
게임 내 획득/소모 로그 중 유료 재화가 오고간 기록(예: 거래소에서 유저간 거래로 이동, 이벤트로 지급 등)을 필터링하여 표시
MySQL의 아이템/재화 로그 테이블이나 MongoDB 로그 컬렉션에서 해당 재화의 증감 이벤트만 추출하여 리스트업 (필드: 유저ID, 변화량, 발생 사유, 시간 등)
UI 제공: 특정 기간 동안의 유료 재화 이동 내역을 조회하는 화면 구성. 거래소 관리 기능과 연계하여 부정 거래 모니터링에도 활용
테스트 결제/아이템 관리: (선택사항) 상점 기능 검증을 위해 마련된 테스트용 아이템의 구매 내역이나 테스트 결제 처리 내용도 조회 가능하도록 구현. 예를 들어 테스트 환경에서만 사용되는 아이템 ID나 결제 플래그를 구분하여 해당 로그를 별도로 필터링하여 볼 수 있게 할 수 있음 (QA 용도로만 사용)
8단계: 거래소 관리 기능 (Marketplace Management)
서버별 거래소 현황 모듈 구현: 게임 내 아이템 거래소(경매장)의 현재 상태를 모니터링하는 기능
서버 선택 드롭다운 및 현황 표시: 선택한 서버의 거래소에 등록된 아이템 목록, 수량, 최저가/최고가, 진행 상태(판매중/판매완료 등)를 조회하여 표로 표시. 모든 서버를 한 번에 보려면 “전체 서버 보기” 옵션으로 통합 리스트 제공
백엔드: MySQL에 서버별 거래소 아이템 테이블 조회 (활성화된 판매 리스트) API 개발. 대량 데이터일 경우 서버별 페이징 처리
거래 내역 로그 조회 구현: 아이템 거래 완료/취소 등에 대한 이력을 확인하는 기능
필터 옵션: 기간, 아이템명/ID, 판매자/구매자 ID 등으로 검색할 수 있는 UI 제공
백엔드: 거래소 거래 로그 테이블 (혹은 MongoDB 로그 컬렉션)에서 필터 조건에 맞는 거래 완료 기록 조회. 각 로그에는 거래 ID, 아이템, 가격, 구매자/판매자, 거래 시각, 결과(완료/취소) 등이 포함
조회된 로그를 표로 표시하고, 필요 시 상세 팝업으로 거래 상세(예: 해당 아이템이 거래된 전체 이력) 보여주기
부정거래 모니터링 기능 구현: RMT(현금거래) 등 불법/비정상 거래를 탐지하기 위한 관리자 도구
의심 패턴 정의: 예를 들어 정상가 대비 지나치게 높은 가격의 거래, 동일 계정들 간 반복 거래, 신규 계정이 고가 아이템 구매 등의 룰을 정의
백엔드에서 해당 조건에 부합하는 거래를 실시간 또는 배치로 분석하여 의심 거래 목록 작성
UI에서는 부정거래 의심 건을 별도 목록/필터로 표시하고, 필요 시 해당 계정에 플래그를 세우거나 바로 조치(계정 조사 요청 등)할 수 있는 버튼 제공
이 기능은 초기에는 수동 로그 확인으로 시작하고, 추후 룰 기반 알림 시스템으로 고도화 (알림 센터와 연계하여 실시간 경고)
테스트용 아이템 거래 관리 구현: 테스트 서버나 QA 환경에서 거래소 기능을 검증하기 위한 도구
더미 아이템 등록/삭제 UI: 운영자가 임의의 아이템을 특정 가격에 거래소에 등록하거나, 반대로 거래를 강제로 완료/삭제해볼 수 있는 기능 (테스트 환경 한정)
MySQL의 거래소 테이블에 직접 더미 데이터를 insert하거나, 게임 서버에 테스트 등록 명령(TCP)을 보내는 방식으로 구현
테스트 거래 이력 관리: 테스트로 발생시킨 거래는 별도로 식별 가능하도록 플래그 저장하고, 해당 이력도 조회 가능하게 제공 (문제 발생 시 추적)
실시간 갱신 고려: 거래소 현황은 실시간 변동 가능성이 높으므로, 필요 시 WebSocket 등을 통해 새로운 거래 발생이나 변경 시 프론트엔드에 업데이트 푸시. 초기 버전에서는 수동 새로고침으로 충분하며, 추후 트래픽 상황에 따라 실시간 갱신 도입
9단계: 로그 및 데이터 분석 시스템 구축 (Logs & Analytics)
게임 로그 조회 기능 구현: 게임 내에서 발생하는 각종 이벤트 로그를 검색/분석하는 모듈
예를 들어 캐릭터 획득 아이템 로그, 재화 증감 로그, 퀘스트 완료 로그 등을 종류별로 조회 가능해야 함. 필터 폼에 유저ID, 로그 유형, 기간 등을 입력하여 해당 조건의 로그를 검색
로그 저장소: 대량의 로그 데이터를 효율적으로 저장/검색하기 위해 MongoDB 컬렉션 활용 (또는 ELK Stack 등 별도 솔루션 고려 가능하나, 기획에 명시된 MongoDB 사용). 로그 타입별로 컬렉션을 분리하거나 공통 컬렉션에 type 필드 구분
백엔드: MongoDB에서 쿼리하여 결과를 전달하는 API 구현. 인덱스 최적화 (예: 유저ID, 시간으로 복합인덱스)로 검색 성능 향상. 필요한 경우 기간별 파티션(Collection 분할) 전략도 수립
프론트엔드: 검색 결과를 표 형태로 보여주고 상세 내용(예: JSON 형태 로그 전문)을 모달로 표시. 데이터가 많을 경우 페이지네이션 및 일괄 Excel 다운로드 기능 제공
채팅 로그 조회 기능 구현: 게임 내 모든 채널의 채팅 내용을 검색할 수 있는 도구
필터 옵션: 유저명/ID, 채널(월드/길드/귓속말 등), 키워드, 기간 등을 제공하여 특정 대화나 욕설 필터링 등에 활용
백엔드: MongoDB 채팅 로그 컬렉션에서 텍스트 검색 쿼리 수행 (필요 시 전문 인덱스 혹은 MongoDB Text Index 사용). 대용량 데이터를 대비하여 시간 범위 필터는 필수, 키워드 검색은 특정 기간에 한해 실행하도록 안내
프론트엔드: 검색 결과를 대화 형태로 보여주거나 표 형태로 나열. 채팅 내용이 길 경우 잘라 표시하고 클릭